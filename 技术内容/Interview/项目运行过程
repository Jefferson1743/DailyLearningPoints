1. 前端页面提交请求，然后传输：source和systemIn两部分信息。

2. /run接收请求，也就是/service/ExecuteStringSourceService.java进行处理，并返回source,systemIn还有runResult。
	ExecuteStringSourceService 通过StringSourceCompiler来编译source源码，生成字节码。
	判断字节码是否为空：
		如果为空，DiagnosticCollector.getDiagnostics实现对compiler过程中的编译报错信息。反馈编译报错信息。
	判断字节码不为空：
		创建callable<string>的task，重写run调用JavaClassExecutor.execute(classByte, systemIn);
		输入字节码，运行。(string 是callable的返回值)
		设置超时，保证JVM正常运行。pool.submint(task).get(run_time, TIME_UNIT.SECOND)

3. 动态编译：StringSourceCompiler。
	总体逻辑：JavaFileObject把字符串变成转化成JavaFileObject字符。
		 JavaFileManager对JavaFileObject实现管理。
		 Java
	内置的JavaFileObject标准实现SimpleJavaFileObject是面向类源码文件，由于动态编译时候输入的是类源码文件的内容字符串，需要自行实现JavaFileObject。
		需要继承SimpleFileObject实现
		
		重写constructor，传入source源码，可以创建相应的JavaFileObject
		重写getCharContent, 返回传入的源码。

		添加字节码属性
		重写openOutputStream(),获取ByteArrayOutputStream
		写入getByteCode(),获取编译后的字节码。

	内置的JavaFileManager是面向类路径下的Java源码文件进行加载，这里也需要自行实现JavaFileManager。
		需要继承ForwardingJavaFileManager<JavaFileManager>
		实现getJavaFileObjectForInput方法
			从内存中去读取JavaFileObject方法（hashmap）。
		实现getJavaFileObjectForOutput方法
			从内存中取出JavaFileObject方法
	需要自定义一个ClassLoader实例去加载编译出来的动态类。
		

	首先从字符串中匹配类名。然后把类名和相应的代码放到concurrenthashmap里面。
	source代码放到simpleJavaFileObject里面，并通过JavaFileObjectManager进行管理。
	代码通过compile进行编译，输出字节码。
4.字节码更改：通过已知的字节码分布规律，前面八个字节是魔数，后面两个是次版本号，主版本号，然后就是常量池，常量池的变量个数，然后就是根据自己的标识和相应的长度进行分布。
	class文件的主要结构：魔数【u4】，文件版本【u2, u2】，常量池【u2，cp_info】，访问标志【u2】，【当前类索引，父类，接口，接口数】【U2，U2，U2，U2】，字段集合【u2，file_info】
	class的常量池(17种)：字面量和符号引用。
	字面量：常量，文本字符串，被final声明的常量值。
	符号引用：被模块导出或者开放的包，类和接口的全限定名，字段的名称和描述符，方法的名称和描述符，方法句柄和方法类型，动态调动点和动态常量。

5. 实现自己的类加载器，重写findclass方法。破坏双亲委派机制。
只要简单继承ClassLoader即可，关键是要覆盖原来的ClassLoader.findClass()方法，用于搜索自定义的JavaFileObject实例，从而提取对应的字节码字节数组进行装载，为了实现这一点可以添加一个哈希表作为缓存，键-值分别是全类名的别名（xx.yy.MyClass形式，而非URI模式）和目标类对应的JavaFileObject实例。
	双亲委派机制的优点：每个类都有自己的特定的加载器，

5. 字节码运行
	处理传入的字节码和相对应的systemIn。
	通过字节码的更改，把scanner和system更改。
	把用户的输入转换成标准输入。
	调用反射执行代码。
	
	system中哪些方法有比较大的问题？
		System.contains等方法
		getProperty
		gc
		setProperties
		exit()
	scanner类不能被extends， 是final类，只能实现Iterator<String> Closeable;
	InputStream 通过Threadlocal实现每个线程都有一个inputstream，设计了get set方法
	public void set(String systemIn) {
		holdInputStream.set(new ByteArrayInputStream(systemIn.getBytes()));
	    }	
	printStream主要通过重写ensureOpen，close， checkError， write方法，对threadLocal中的in进行修改。并且添加getBuf

	IN,OUT是两个静态变量。

	


