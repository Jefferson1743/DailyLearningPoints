# Java面试的基础
[toc]
## Java的三大特性
封装、继承、多态

## 多态，多态的优点

多态指的是相同类型的变量在调用同一个方法时呈现出多种不同的行为特征。而造成这一现象的原因在于Java中的变量有两个类型：

    编译时类型，由声明变量时的类型决定。

    运行时类型，由实际赋值给变量的对象的类型决定，

当一个变量的两个类型不一致，就会出现多态。

派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。 

## 重载（Overload）和重写（Override）的区别？重载的方法能否根据返回类型进行区分？

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。

重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。

重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。

重载对返回类型没有特殊的要求，不能根据返回类型进行区分。


## 编译型语言、解释型语言、伪编译型语言的区别

编译型编程语言

指的是用专门的编译器，对于针对特定平台将某种高级语言编写的源代码一次性编译成可在该平台硬件执行的机器码，并打包成该平台所能识别的可执行性程序的格式。优点是执行效率比较高，缺点是无法跨平台运行。需要移植到其他平台上运行，需要采用特定平台的编译器重新编译。C,C++,Objective-C,Swift,Kotlin都属于此类。

解释型编程语言

使用特定的解释器对源代码进行逐行解释并立即执行的的语言。缺点是因为每次执行都需进行编译，运行效率低，而且不能脱离解释器独立运行，优点是可以跨平台运行，只要在特定平台上提供特定的解释器就行了。JavaScript，Ruby，Python都属于此类。

伪编译型语言

编译时只编译成中间代码，将中间代码和解释器一起打包成可执行文件。然后执行时使用解释器将中间代码解析成二进制代码。Visual Basic属于此类。

Java Java是通过javac编译器将源代码编译成跟平台无关的字节码（也就是.class文件），然后由不同平台上的 JVM（Java虚拟机）对字节码解释执行，在一些Java虚拟机的实现中，还会将字节码转换为特定系统的机器码，提高执行效率。Java语言不属于上面的任何一类，因为目前的高级语言较为复杂，已经不能简单地以编译型编程语言，解释型编程语言，伪编译型语言进行划分了。

## 变量、代码块、构造器之间的执行顺序

Java程序中类中个元素的初始化顺序 初始化的原则是：

    先初始化静态部分，再初始化动态部分，

    先初始化父类部分，后初始化子类部分，

    先初始化变量，再初始化代码块和构造器。

所以依照这个规则可以得出总体顺序是：

    1.父类的静态成员变量（如果是第一次加载类）

    2.父类的静态代码块（如果是第一次加载类）

    3.子类的静态成员变量（如果是第一次加载类）

    4.子类的静态代码块（如果是第一次加载类）

    5.父类的普通成员变量

    6.父类的动态代码块

    7.父类的构造器方法

    8.子类的普通成员变量

    9.子类的动态代码块

    10.子类的构造器方法


## 抽象类的特点

从多个具体的类中抽象出来的父类叫做抽象类，抽象类就像是一个模板。抽象类使用abstract关键字修饰，抽象类可以拥有抽象方法（使用abstract修饰的方法，由子类来提供方法的实现）。抽象类的特点如下：

1.可以包含抽象方法

抽象方法与普通方法的区别在于，抽象类不提供抽象方法的实现，由继承抽象类的子类实现抽象方法。

2.不能实例化

也正因为包含抽象方法，抽象类不能被实例化。抽象类的构造器不能用于创建实例，是仅提供给子类调用的。除此以外，抽象类跟普通类一样，可以拥有成员变量，普通方法，构造器，初始化块，内部类，枚举等。

3.抽象类可以被继承

继承抽象类的子类如果实现了所有抽象方法，那么可以作为普通类使用，否则也只能作为抽象类。

## Java中的访问控制符
访问范围|private|default|protected|public
:-:|:-:|:-:|:-:|:-:
本类中|允许|允许|允许|允许
同一包中||允许|允许|允许
其他包中的子类|||允许|允许
其他包中||||允许

## Java中的内部类是怎么样的

内部类分为静态内部类和非静态内部类。静态内部类是与外部类相关的，而非静态内部类是与外部类的实例对象相关的。

静态内部类
静态内部类一般使用public static修饰，也可以使用private static使用，那样只能在外部类内部使用。在外部类以外的地方使用静态类时，需要带上外部类的包名，例如创建一个静态内部类对象：

OutClass.InnerClass object = new OutClass.InnerClass();

非静态内部类

非静态内部类是跟外部类的实例对象绑定在一起的。外部类一般是由两种访问修饰符default（只能包内访问），public（所有位置可以访问）。而非静态内部类有private，default，protected，public四种访问修饰符。因为必须跟外部类的实例对象绑定在一起，所以非静态内部类不能有静态方法，静态成员变量，静态初始化块，在外面创建一个非静态内部类对象：

OutClass out = new OutClass();
OutClass.InnerClass object = out.new InnerClass();

## final关键字

修饰类：final修饰类时，类不能被继承，并且类中的所有方法都被隐式地使用final修饰。

修饰方法：方法不能被子类重写。

修饰变量：final修饰的变量一旦初始化，就不能被修改。当final修饰实例变量时，可以在在定义变量时赋初值，也可以在定义时不赋值，在动态代码块，或构造器中赋初值。（只能赋值一次）。

如果final变量在声明时就指定了初始值，并且在编译时可以确定下来，那么在编译时，final变量本质上会变成一个宏变量，所有用到该变量的地方都直接替换成该变量的值。

## 常量池
Integer
```JSON
通过new Interger()创建Interger对象，每次返回全新的Integer对象

通过Interger.valueOf()创建Interger对象，如果值在-128到127之间，会返回缓存的对象(初始化时)。

实现原理:

Integer类中有一个静态内部类IntegerCache，在加载Integer类时会同时加载IntegerCache类，IntegerCache类的静态代码块中会创建值为-128到127的Integer对象，缓存到cache数组中，之后调用Integer#valueOf方法时，判断使用有缓存的Integer对象，有则返回，无则调用new Integer()创建。
```
## Java的构造器有哪些特点？

1. 如果没有自定义构造器，系统会提供一个默认的无参数构造器。如果提供了自定义的构造器，系统就不会提供默认的无参数构造器。(也就是不能直接调用new Test()来创建一个对象了，除非自己自定义一个无参数构造器)。

2. 在上面的代码中，其实在构造器Test(String str)调用之前，系统已经分配好空间，创建一个对象，然后执行构造器Test(String str)方法对对象进行初始化，然后返回。

3. 构造器一般使用public修饰符修饰，也可以使用protected，private来限制访问。

4. 构造器重载，指的是一个类可以有多个构造器，多个构造器的参数列表不同。

## Java中的注解Java中的注解是什么？
Java中的注解其实是继承于annotation接口的一个接口，根据@Retention修饰的作用范围，注解可以是作用于源码层面，字节码文件层面，运行时层面。

    // 如果@Retention的值是RetentionPolicy.Source 那么在编译时注解就失效了，不会编译进class文件
    // 如果@Retention的值是RetentionPolicy.CLASS 那么会编译进class文件，但是JVM加载class文件时就会丢弃这个注解，在运行时注解就失效了
    // 如果@Retention的值是RetentionPolicy.RUNTIME 在运行时注解同样有效
点击复制代码复制出错复制成功
根据@Retention的值，注解主要分为编译时扫描和运行时扫描，例如@Override注解是作用于源码层面的，只是在编译时，编译器会去检验method是否是真正重写了父类的某个方法。

@Override
public void method() {

}


@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {

}
点击复制代码复制出错复制成功
除了几个JDK自带的注解以外，通常情况下，我们使用的注解都是运行时注解，在运行时，JVM在运行时会针对注解生成一个动态代理类，通过反射获取注解时，实际上返回的是Java运行时生成的动态代理对象$Proxy1，而Proxy类就是我们注解（接口）的具体实现类。



## String、StringBuffer、StringBuilder之间的区别

1.可变性
String是一个不可变类，任何对String改变都是会产生一个新的String对象，所以String类是使用final来进行修饰的。而StringBuffer和StringBuilder是可变类，对应的字符串的改变不会产生新的对象。

2.执行效率
当频繁对字符串进行修改时，使用String会生成一些临时对象，多一些附加操作，执行效率降低。

stringA = StringA + "2";
//实际上等价于
{
  StringBuffer buffer = new StringBuffer(stringA)
  buffer.append("2");
  return buffer.toString();
}
点击复制代码复制出错复制成功
在对stringA进行修改时，实际上是先根据字符串创建一个StringBuffer对象，然后调用append()方法对字符串修改，再调用toString()返回一个字符串。

3.线程安全
StringBuffer的读写方法都使用了synchronized修饰，同一时间只有一个线程进行操作，所以是线程安全的，而StringBuilder不是线程安全的。

## Object类有哪些自带方法？
1. registerNatives()

首先Object类有一个本地方法registerNatives()，会在类加载时调用，主要是将Object类中的一些本地方法绑定到指定的函数中去，便于之后调用。例如将hashCode和clone本地方法绑定到JVM_IHashCode和JVM_IHashCode函数。

2. getClass()

getClass()方法会返回对象的运行时类。

3. Class.forName()



与getClass()类似的方法还有两个，一个是Class类中的forName()方法，也是在运行时，根据传入的类名去加载类，然后返回与类关联的Class对象。也正是因为是动态加载，在编译时可以没有这个类，也不会对类名进行检验，所以有可能抛出ClassNotFoundException异常。

4. clone()方法

clone()方法会创建并返回当前对象的副本。副本与原对象的区别在于它们相等，但是存储在不同的内存位置中。

要调用clone()方法必须实现Cloneable接口，否则调用默认的Object类的clone方法会抛出CloneNotSupportedException异常。默认clone()方法返回的对象是浅拷贝的。

5. toString()方法

返回类名+@+hashCode的16进制字符串

6. wait()

wait()方法可以让当前线程放弃对象的监视器(可以简单认为监视器就是一个锁)，进入等待队列，进行等待，直到其他线程调用notify()或者notifyAll()后(或者过了超时时间)，线程才会从等待队列，移动到同步队列，再次获得对象的监视器后才能继续执行。

7. notify()

notify()可以唤醒等待队列中的某一个线程，线程被唤醒后会从等待队列移动到同步队列，线程再次获得对象的监视器后才能继续执行。（然后调用notify()方法的线程会继续执行，在同步块中执行完毕后，会释放对象的监视器。）

8. notifyAll()

notifyAll()方法与notify()方法类似，只是会将等待队列中的所有线程唤醒。

9. finalize()

当垃圾回收器确认某个对象不被任何其他对象引用时(即对象处于可恢复状态)，系统在回收对象时，会调用finalize()方法，可以在这个方法中清理资源，在这个方法中，也有可能让对象重新获得引用，从而变成可达状态。


## 为什么hashCode()和equals()方法要一起重写？

假如只重写hashCode()方法（结果：HashMap可以存在两个内存地址不相同，但是相等的对象，无法保证去重）

此时equals()方法的实现是默认实现，也就是当两个对象的内存地址相等时，equals()方法才返回true，假设两个键值对，它们的key类型都是TestObject，的值都是test，但是由于是使用new String()创建而成的字符串对象，key1和key2的内存地址不相等，所以key1==key2的结果会是false，TestObject的equals()方法默认实现是判断两个对象的内存地址，所以 key1.equals(key2)也会是false， 所以两个键值对可以重复地添加到hashMap中去。

假如只重写equals()方法（结果：相同的对象hashCode不同，从而映射到不同下标下，HashMap无法保证去重）

假设只equals()方法，hashCode方法会是默认实现，具体的计算方法取决于JVM，可能会导致两个相等的对象，它们的hashCode却不相同，从而计算得到的数组下标不相同，存储到hashMap中不同数组下标下的链表中，也会导致HashMap中存在重复元素。

1. hashCode()和equals()方法
可以看到Obejct类中的源码如下，可以看到equals()方法的默认实现是判断两个对象的内存地址是否相同来决定返回结果。

2. hashCode()方法的作用有哪些？
    a. 对对象做散列

    为了将一组键值对均匀得存储在一个数组中，HashMap对key的hashCode进行计算得到一个hash值，用hash对数组长度取模，得到数组下标，将键值对存储在数组下标对应的链表下。

    b. 快速判断对象是否不相等

    因为两个对象hashCode相等，调用equals()方法的结果不一定为true，

    因为两个对象调用equals()方法相等，hashCode一定相等。

    所以hashCode不相等可以作为两个对象不相等的快速判断条件。

    在往HashMap中添加一个键值对时，计算得到数组下标后，会遍历数组下标下存储的链表中，拿key的hashCode与每个节点的hashCode进行比较，相等时，才调用equals()方法进行继续调用，节约时间。（在一些类的equal()方法的自定义实现中也会对hashCode进行判断）。

