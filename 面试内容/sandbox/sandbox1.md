# sandbox设计理念

**JVM-SANDBOX（沙箱）实现了一种在不重启、不侵入目标JVM应用的AOP解决方案。**

## 设计初衷

1. 第一种方案：SpringAOP的方式来完成相对业务代码透明的AOP织入方式。

```txt

1. 不是所有业务代码都托管在Spring容器中
2. 更底层的中间件代码、三方包代码无法纳入到回归范围。
3. 测试框架会引入自身所依赖的类库，经常与业务代码的类库产生冲突。
```

2. 第二种方案：在更底层的JVMTI来完成这套AOP逻辑的实现，破坏了双亲委派原则来实现类的隔离策略。
```txt
1. 在这一层实现AOP，尤其是attach的启动模式，对现有的AOP字节码编织方案都做了限制，JDKProxy、CgLib等常见的AOP实现框架都无法满足需求，所以我们用ASM构造了一套精巧的字节码编织策略。
```

## 功能需求

1. 在JVM-Sandbox的世界观中，任何一个Java方法的调用都可以分解为BEFORE、RETURN和THROWS三个环节，由此在三个环节上引申出对应环节的事件探测和流程控制机制。不仅如此还有LINE事件，可以完成代码行的记录。基于BEFORE、RETURN和THROWS三个环节事件以及LINE事件，可以完成很多类AOP的操作。

```txt
1. 感知和改变方法调用的入参
2. 可以感知和改变方法调用返回值和抛出的异常
3. 可以感知一个请求按顺序执行了哪些行
4. 可以改变方法执行的流程等。
```

## 项目简介


### 沙箱的特性

1. `无侵入`：目标应用无需重启也无需感知沙箱的存在
1. `类隔离`：沙箱以及沙箱的模块不会和目标应用的类相互干扰
1. `可插拔`：沙箱以及沙箱的模块可以随时加载和卸载，不会在目标应用留下痕迹
1. `多租户`：目标应用可以同时挂载不同租户下的沙箱并独立控制
1. `高兼容`：支持JDK[6,11]

### 沙箱常见应用场景

- 线上故障定位
- 线上系统流控
- 线上故障模拟
- 方法请求录制和结果回放
- 动态日志打印
- 安全信息监测和脱敏

*JVM-SANDBOX还能帮助你做很多很多，取决于你的脑洞有多大了。*

### 实时无侵入AOP框架

在常见的AOP框架实现方案中，有静态编织和动态编织两种。

1. **静态编织**：静态编织发生在字节码生成时根据一定框架的规则提前将AOP字节码插入到目标类和方法中，实现AOP；
2. **动态编织**：动态编织则允许在JVM运行过程中完成指定方法的AOP字节码增强.常见的动态编织方案大多采用重命名原有方法，再新建一个同签名的方法来做代理的工作模式来完成AOP的功能(常见的实现方案如CgLib)，但这种方式存在一些应用边界：
   - **侵入性**：对被代理的目标类需要进行侵入式改造。比如：在Spring中必须是托管于Spring容器中的Bean
   - **固化性**：目标代理方法在启动之后即固化，无法重新对一个已有方法进行AOP增强
 
要解决`无侵入`的特性需要AOP框架具备 **在运行时完成目标方法的增强和替换**。在JDK的规范中运行期重定义一个类必须准循以下原则
  1. 不允许新增、修改和删除成员变量
  1. 不允许新增和删除方法
  1. 不允许修改方法签名

JVM-SANDBOX属于基于Instrumentation的动态编织类的AOP框架，**通过精心构造了字节码增强逻辑，使得沙箱的模块能在不违反JDK约束情况下实现对目标应用方法的`无侵入`运行时AOP拦截**。

## 核心原理

### 事件驱动

在沙箱的世界观中，任何一个Java方法的调用都可以分解为`BEFORE`、`RETURN`和`THROWS`三个环节，由此在三个环节上引申出对应环节的事件探测和流程控制机制。

```java
// BEFORE
try {

   /*
    * do something...
    */

    // RETURN
    return;

} catch (Throwable cause) {
    // THROWS
}
```

基于`BEFORE`、`RETURN`和`THROWS`三个环节事件分离，沙箱的模块可以完成很多类AOP的操作。

1. 可以感知和改变方法调用的入参
1. 可以感知和改变方法调用返回值和抛出的异常
1. 可以改变方法执行的流程
    - 在方法体执行之前直接返回自定义结果对象，原有方法代码将不会被执行
    - 在方法体返回之前重新构造新的结果对象，甚至可以改变为抛出异常
    - 在方法体抛出异常之后重新抛出新的异常，甚至可以改变为正常返回

### 类隔离策略

沙箱通过自定义的SandboxClassLoader破坏了双亲委派的约定，实现了和目标应用的类隔离。所以不用担心加载沙箱会引起应用的类污染、冲突。各模块之间类通过ModuleJarClassLoader实现了各自的独立，达到模块之间、模块和沙箱之间、模块和应用之间互不干扰。

![jvm-sandbox-classloader](https://github.com/alibaba/jvm-sandbox/wiki/img/jvm-sandbox-classloader.png)

### 类增强策略

沙箱通过在BootstrapClassLoader中埋藏的Spy类完成目标类和沙箱内核的通讯

![jvm-sandbox-enhance-class](https://github.com/alibaba/jvm-sandbox/wiki/img/jvm-sandbox-enhance-class.jpg)

### 整体架构

![jvm-sandbox-architecture](https://github.com/alibaba/jvm-sandbox/wiki/img/jvm-sandbox-architecture.png)